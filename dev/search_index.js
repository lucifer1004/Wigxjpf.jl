var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Wigxjpf","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wigxjpf.jl is an unopinionated wrapper of WIGXJPF, which evaluates Wigner 3j, 6j and 9j symbols accurately using prime factorisation and multi-word integer arithmetic.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Similar to the Python wrapper pywigxjpf, the following 8 functions are exported.","category":"page"},{"location":"#Standard-(Float64)-Precision","page":"Home","title":"Standard (Float64) Precision","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The default functions return Float64 values:","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Wigxjpf]","category":"page"},{"location":"#Wigxjpf.wig3jj-NTuple{6, Integer}","page":"Home","title":"Wigxjpf.wig3jj","text":"wig3jj(two_j1::Integer, two_j2::Integer, two_j3::Integer, two_m1::Integer, two_m2::Integer, two_m3::Integer)\n\nEvaluate Wigner 3-j symbols. Note that all parameter are twice the actual j or m parameters to allow representation of half-integers.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig6jj-NTuple{6, Integer}","page":"Home","title":"Wigxjpf.wig6jj","text":"wig6jj(two_j1::Integer, two_j2::Integer, two_j3::Integer, two_j4::Integer, two_j5::Integer, two_j6::Integer)\n\nEvaluate Wigner 6-j symbols. Note that all parameter are twice the actual j parameters to allow representation of half-integers.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig9jj-NTuple{9, Integer}","page":"Home","title":"Wigxjpf.wig9jj","text":"wig9jj(two_j1::Integer, two_j2::Integer, two_j3::Integer, two_j4::Integer, two_j5::Integer, two_j6::Integer, two_j7::Integer, two_j8::Integer, two_j9::Integer)\n\nEvaluate Wigner 9-j symbols. Note that all parameter are twice the actual j parameters to allow representation of half-integers.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig_table_free-Tuple{}","page":"Home","title":"Wigxjpf.wig_table_free","text":"wig_table_free()\n\nFree the calculation table.\n\nWhen used in a multi-threaded environment, this function should be called globally.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig_table_init-Tuple{Integer, Integer}","page":"Home","title":"Wigxjpf.wig_table_init","text":"wig_table_init(max_two_j::Integer, wigner_type::Integer)\n\nInitialize the calculation table. Must be called before evaluating any Wigner symbols.\n\nmax_two_j is twice the highest absolute value of all j values to be evaluated.\n\nwigner_type should be 3, 6, or 9. When multiple types are to be used, you should use the highest value for this parameter.\n\nWhen used in a multi-threaded environment, this function should be called globally.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig_temp_free-Tuple{}","page":"Home","title":"Wigxjpf.wig_temp_free","text":"wig_temp_free()\n\nFree the temporary array.\n\nWhen used in a multi-threaded environment, this function should be called in each thread.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig_temp_init-Tuple{Integer}","page":"Home","title":"Wigxjpf.wig_temp_init","text":"wig_temp_init(max_two_j::Integer)\n\nInitialize the temporary array. Must be called before evaluating any Wigner symbols.\n\nWhen used in a multi-threaded environment, call wig_thread_temp_init instead.\n\n\n\n\n\n","category":"method"},{"location":"#Wigxjpf.wig_thread_temp_init-Tuple{Integer}","page":"Home","title":"Wigxjpf.wig_thread_temp_init","text":"wig_thread_temp_init(max_two_j::Integer)\n\nInitialize the temporary array. Must be called before evaluating any Wigner symbols.\n\nWhen used in a multi-threaded environment, this function should be called in each thread.\n\n\n\n\n\n","category":"method"},{"location":"#High-(Float128)-Precision","page":"Home","title":"High (Float128) Precision","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For applications requiring higher precision than Float64, Float128 (quad precision) support is available through the Quadmath.jl package extension.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Requirements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia 1.9 or later (for package extensions)\nx86/x86_64 architecture\nLinux or Windows operating system\nQuadmath.jl package","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: Float128 is not available on macOS (Intel or Apple Silicon) or ARM architectures due to lack of libquadmath support.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Usage:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Wigxjpf\nusing Quadmath  # This enables Float128 support\n\nwig_table_init(200, 9)\nwig_temp_init(200)\n\n# Use Float128 as the first argument to get quad precision\nval3j_f128 = wig3jj(Float128, 2 * 10, 2 * 15, 2 * 10, 2 * (-3), 2 * 12, 2 * (-9))\nval6j_f128 = wig6jj(Float128, 2 * 10, 2 * 15, 2 * 10, 2 * 7, 2 * 7, 2 * 9)\nval9j_f128 = wig9jj(Float128, 1, 2, 3, 4, 6, 8, 3, 6, 9)\n\nwig_temp_free()\nwig_table_free()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Float128 provides approximately 33-34 decimal digits of precision (compared to 15-16 for Float64), which is beneficial for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Large angular momenta values where cancellation errors accumulate\nApplications requiring verified high-precision results\nNumerical stability analysis","category":"page"},{"location":"#Multi-threading","page":"Home","title":"Multi-threading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For multi-threaded applications, each thread must initialize its own temporary storage using wig_thread_temp_init:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Wigxjpf\n\n# Global initialization (once, before spawning threads)\nwig_table_init(200, 9)\n\n# Parallel computation\nresults = Vector{Float64}(undef, 100)\nThreads.@threads for i in 1:100\n    # Initialize thread-local temporary storage\n    wig_thread_temp_init(200)\n\n    # Compute in this thread\n    results[i] = wig3jj(2 * i, 2 * 10, 2 * 15, 0, 0, 0)\n\n    # Clean up thread-local storage\n    wig_temp_free()\nend\n\n# Global cleanup (once, after all threads complete)\nwig_table_free()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Important threading notes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"wig_table_init() must be called once globally before any threaded computation\nwig_thread_temp_init() must be called in each thread before computing\nwig_temp_free() must be called in each thread after computing\nwig_table_free() must be called once globally after all threads complete\nFloat128 works with multi-threading (each thread handles Float128 independently)","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Wigxjpf\n\nwig_table_init(200, 9)\nwig_temp_init(200)\n\nval3j = wig3jj(2 * 10, 2 * 15, 2 * 10, 2 * (-3), 2 * 12, 2 * (-9))\n\n@show val3j # \"val3j = 0.040013817682832936\"\n\nval6j = wig6jj(2 * 10, 2 * 15, 2 * 10, 2 * 7, 2 * 7, 2 * 9)\n\n@show val6j # \"val6j = 0.01033149734335741\"\n\nval9j = wig9jj(1, 2, 3, 4, 6, 8, 3, 6, 9)\n\n@show val9j # \"val9j = -0.003015611935232274\"\n\nwig_temp_free()\nwig_table_free()","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The recommended way to refer to WIGXJPF, when used for computations that are published in a research article, is to cite the following paper: H. T. Johansson and C. Forss√©n, Fast and Accurate Evaluation of Wigner 3j, 6j, and 9j Symbols Using Prime Factorization and Multiword Integer Arithmetic, SIAM J. Sci. Comput., 38(1) (2016), A376-A384.","category":"page"}]
}
